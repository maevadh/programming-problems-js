# JS a revisar Elkin

Statut: TerminÃ© âœ¨

> âœ…Â Con un bucle for, tomar cada elemento/string del array y unirlos en un Ãºnico string:
> 

ExplicaciÃ³n: 

```jsx
// la respuesta deberÃ­a ser: 'JavaScript CSS HTML Python'

let strs = ["JavaScript", "CSS", "HTML", "Python"];
let s = '';
for (let i = 0; i < strs.length; i++) {
  s = s + strs[i] + ' '
}

console.log(s);
```

El bucle recorre cada elemento del array y con la ayuda del operador + unimos/concatenamos cada elemento en un Ãºnico string.

> âœ…Â Â Â¿CuÃ¡l es el resultado?:
> 

```jsx
let arr = [1, 2];
let res = arr.push(3);
console.log(res);
```

ExplicaciÃ³n: 

```jsx
let arr = [1, 2];
let res = [3];
console.log(res);
```

El mÃ©todo .push() agrega el elemento pasado en value al final del array y **devuelve la longitud**. Si quiero el resultado final tengo que volver a hacer un console.log() del array.

Entonces, console.log(res) â†’ 3. 

> âœ…Â Â¿CuÃ¡l es el resultado?:
> 

```jsx
let arr = [1, 2];
let res = arr + 1;
console.log(res);
```

- [x]  `1,21`
- [ ]  `4`
- [ ]  `[1, 2, 1]`
- [ ]  Ninguna

ExplicaciÃ³n: 

Los array no tienen Symbol.toPrimitive tampoco valueOf, tienen solamente toString. Entonces la conversion del arr se convierte en "1,2â€. 

La coercion convierte un array en un string con el +

"1,2â€ + 1 â†’ 1,21

> âœ…Â Â¿CuÃ¡l es el resultado?:
> 

```jsx
let arr = 'array'.split('r');
arr[2] = 'l';
console.log(arr.join(''));
```

- [x]  `arlay`
- [ ]  `array`
- [ ]  Error de JavaScript.
- [ ]  Ninguna

ExplicaciÃ³n:

el mÃ©todo .split sirve a separar un string en function de un separator que en esta caso es [2] y convertirlo en un array la posiciÃ³n numero 2 (la r), la reemplaza y luego haces un .join() de todo eso. TambiÃ©n el hecho de hacer (â€â€) le indica de ponerse en string que seria distinto sin comillas, todo se pondrÃ­a separado con una coma. â†’arlay

> âœ…Â Â¿cuÃ¡l es el resultado?
> 

```jsx
if(10*0 > -2) {
	console.log('go in!')
} else {
	console.log('go out!')
}
```

ExplicaciÃ³n:

if(10*0 > -2)   â†’   if(0 > -2)   â†’ true â†’ se cumple la condiciÃ³n â†’ **'Go in!'**

> âœ…Â Â¿cuÃ¡l es el resultado?
> 

```jsx
if (3 > 2 * (2 < 1)) {
	console.log('Go in!');
} else {
	console.log('Go out!');
}
```

ExplicaciÃ³n:

Ojo al orden de los operadores. Empezamos por las parÃ©ntesis, luego la multiplication y luego comparemos si el resultado es verdadero o falso. 

if (3 > 2 * (2 < 1))     â†’     if (3 > 2) * (false)     â†’    3 > (2 * 0)    â†’    (3 > 0)   â†’ true 

â†’ se cumple la condiciÃ³n â†’ **â€˜Go in!â€™**

> âœ…Â Â¿cuÃ¡l es el resultado?
> 

```objectivec
if (true >= 1 && 0 === '0') {
	console.log('Go in!');
} else {
	console.log('Go out!');
}
```

ExplicaciÃ³n:

if (true >= 1 && 0 === '0') â†’ if ( 1 â‰¥ 1   &&   0 === â€˜0â€™)

=== verifica el valeur + el tipo de datos. 

if (true && false) â†’ false â†’  no se cumple la condiciÃ³n â†’ **â€˜Go out!â€™**

> âœ…Â Hacer un loop de cada uno de los elementos del Array y solo hacer console.log de los elementos que son un string.
> 

```jsx
let arr = [1, '2', '3', 4, '5', '7', 8, 9];
for() {
	if() {
		console.log()
	}
}
```

ExplicaciÃ³n:

```jsx
let arr = [1, '2', '3', 4, '5', '7', 8, 9];

for(let i = 0; i < arr.length; i++) {
	if(typeof arr[i] === 'string') {
		console.log(arr[i])
	}
}
```

> âœ…Â Hacer un loop de cada uno de los elementos del Array y solo hacer console.log de los elementos que son un nÃºmero.
> 

```jsx
let arr = [1, '2', '3', 4, '5', '7', 8, 9];
for() {
	if() {
		console.log()
	}
}
```

ExplicaciÃ³n:

```jsx
let arr = [1, "2", "3", 4, "5", "7", 8, 9];
for (let i = 0; i < arr.length; i++) {
if (typeof arr[i] === "number") {
console.log(arr[i]);
}
}
```

> âœ…Â Â¿CuÃ¡l es el resultado?:
> 

```jsx
let arr = 'array';
arr[2] = 'l';
console.log(arr);
```

- [ ]  `arlay`
- [ ]  `array`
- [x]  Error de JavaScript.
- [ ]  Ninguna

ExplicaciÃ³n:

Resulta un error porque un string es un tipo de dato primitivo, inmutable. 

> âœ…Â Â¿cuÃ¡l es el resultado?
> 

```jsx
const obj = { a: 1, b: 10 };
const obj1 = { a: obj, b: obj.b };

console.log(obj === obj1.a);
```

Hints: *[accessors](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Property_Accessors), [object references](https://javascript.info/object-copy)*

ExplicaciÃ³n:

{ a: 1, b: 10 };
{ a: { a: 1, b: 10 }, b: 10 };

console.log({ a: 1, b: 10 } === { a: 1, b: 10 }); â†’ **true porque obj1.a = obj, son la misma referencia.**

> âœ…Â Â¿cuÃ¡l es el resultado?
> 

```jsx
const target = { a: 1, b: 2 };
const source = { b: 4, c: 5 };

const returnedTarget = Object.assign(target, source);

const sum = returnedTarget.b + source.b;
console.log(sum);
```

ExplicaciÃ³n:
El mÃ©todo Object.assign(target, ...sources) recibe 2 parÃ¡metros y copia las propiedades del segundo elemento al primero. Aun existÃ­a un valor b en el segundo parÃ¡metro asÃ­ que se ha borrado el de la variable target. Ahora, target  = { a: 1, b: 4, c: 5 };

const returnedTarget =  { a: 1, b: 4, c: 5 };

const sum = 4 + 4;

console.log(4 + 4); â†’ **8**

> âœ…Â Â¿cuÃ¡l es el resultado?
> 

```jsx
const target = { a: 1, b: 2 };
const source = { b: 4, c: 5 };

Object.assign(target, source);

const sum = target.b + source.b;
console.log(sum);
```

ExplicaciÃ³n:

Object.assign(target, source);

target = { a: 1, b: 4, c: 5 }; 

source = { b: 4, c: 5 };

const sum = target.b + source.b; â†’ const sum = 4 + 4;
console.log(sum); â†’ console.log(4 + 4) â†’ **8**

El mÃ©todo Object.assign(target, ...sources) recibe 2 parÃ¡metros y copia las propiedades del segundo elemento al primero.

> âœ…Â Â¿cuÃ¡l es el resultado?
> 

```jsx
const obj = { a: 1, b: [1, 2] };
const obj1 = { a: 1, b: [1, obj.a] };
const foo = Object.values(obj1)[1][0];
console.log(!!foo);
```

ExplicaciÃ³n:

const foo = 1;

console.log(!!foo); â†’ 1 = true. â†’ !!foo = true. â†’ **true**.

> âœ…Â Â¿cuÃ¡l es el resultado?
> 

```jsx
const obj = { a: 1, b: [1, 2] };
const obj1 = { a: 1, b: [1, obj.a] };

console.log(Object.keys(obj1)[0] === 'b');
```

ExplicaciÃ³n:

Object.keys devuelve las propiedades. Entonces Object.keys(obj1)[0] â†’ a. 

console.log(â€™aâ€™ === 'b'); â†’ false. 

> âœ…Â Â¿cuÃ¡l es el resultado?
> 

```jsx
const obj = { a: 1, b: [1, 2] };
const obj1 = { a: 1, b: [1, obj.a] };

console.log(obj.b[0] === obj1.b[1]);
```

ExplicaciÃ³n:

console.log(1 === 1); â†’ true, obj1.b[1] es una copia de obj.a, el valor se ha copiado.

> âœ…Â Â¿cuÃ¡l es el resultado?
> 

```jsx
const obj = { a: 1, b: [1, 2] };
const obj1 = { a: 1, b: [1, obj.a] };

console.log(obj.b[1] === obj1.a);
```

ExplicaciÃ³n:

console.log(2 === 1);  â†’ false. No tienen el mismo valor.

> âœ…Â Â¿cuÃ¡l es el resultado?
> 

```jsx
const obj = { a: 1, b: [1, 2] };
const obj1 = { a: 1, b: [1, obj] };

console.log(obj.a === obj1.b[1].a);
```

ExplicaciÃ³n:

console.log(1 === 1); â†’ **true** porque tienen la misma referencia en la memoria, la ref de obj se ha copiado. 

> âœ…Â Â¿cuÃ¡l es el resultado?
> 

```jsx
const obj = { a: 1, b: [1, 2] };
const obj1 = { a: 1, b: [1, obj] };

console.log(obj === obj1.b[1]);
```

ExplicaciÃ³n:

console.log({ a: 1, b: [1, 2] } === { a: 1, b: [1, 2] }); â†’ **true**, tienen el mismo valor y referencia en la memoria.

> âœ…Â Â¿cuÃ¡l es el resultado?
> 

```jsx
const obj = { a: 0, b: [1, 2] };
const obj1 = { a: 0, b: [1, 2] };

console.log(!obj.a === !!obj1.a);
```

ExplicaciÃ³n:

Console.log(!0===!!0) â†’ false porque el operador Not inversa el resultado y el double Not fuerza el resultado asÃ­ que !false se vuelve true y (1===0) es false.

> âœ…Â Â¿cuÃ¡l es el resultado?
> 

```jsx
const obj = { a: 0, b: [1, 2] };
const obj1 = { a: obj, b: [1, 2] };

console.log(obj.a === obj1.a.a);
```

ExplicaciÃ³n:

console.log(0 === 0) â†’ true, tienen el mismo valor y la misma referencia en la RAM.

> âœ…Â Â¿cuÃ¡l es el resultado?
> 

```jsx
const obj = { a: 0, b: [1, 2] };
const obj1 = { a: obj, b: [1, 2] };

console.log(!!obj.a === !!obj1.a);
```

ExplicaciÃ³n:

El operador double not!! forza la conversiÃ³n.

Console.log(!!0 ===!!{ a: 0, b: [1, 2] }) -> false. 

> âœ…Â Â¿cuÃ¡l es el resultado?
> 

```jsx
const obj = { a: 0, b: [1, 2] };
const obj1 = { a: obj, b: [1, 2] };

console.log(!!obj === !!obj1);
```

ExplicaciÃ³n:

```jsx
obj = { a: 0, b: [1, 2] }
obj1 = { a: { a: 0, b: [1, 2] }, b: [1, 2] }

console.log(true === true);

```

=== verifica el valor + el tipo de datos

Un object siempre es un valor true. 

> âœ…Â Â¿cuÃ¡l es el resultado?
> 

```jsx
const obj = { a: 1, b: [1, 2] };
const obj1 = { a: obj, b: [1, 2] };

console.log(obj.b[1] === obj1.b[1]);
```

ExplicaciÃ³n:

obj = { a: 1, b: [1, 2] };

obj1 = { a: { a: 1, b: [1, 2] }, b: [1, 2] };

console.log(2 === 2); â†’ true â†’ tienen el mismo valor y tipo de datos.

> âœ…Â Usa la funciÃ³n prompt() para pedirle al usuario que ingrese su edad. Luego hacer un `if...else` . En la condiciÃ³n del if informa si el usuario es mayor de edad, de lo contrario (else) informa con un console.log que es menor de edad.
> 

ExplicaciÃ³n:

```jsx
let edad = prompt('Ingresa su edad :');
if(+edad >= 18){
console.log('Eres mayor de edad!ðŸ’¯')
} else {
console.log('Eres minor de edad ðŸ«£!')
};
```